I'll generate the corrected code that addresses all the file structure deviations by creating separate modular JavaScript files as specified in the implementation plan.

```json
{
  "files": [
    {
      "name": "index.html",
      "path": "index.html",
      "language": "html",
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Galaxy Defender</title>\n    <link rel=\"stylesheet\" href=\"styles.css\">\n</head>\n<body>\n    <div class=\"game-container\">\n        <canvas id=\"gameCanvas\" width=\"800\" height=\"600\"></canvas>\n        \n        <!-- Game UI Overlay -->\n        <div id=\"gameUI\" class=\"ui-overlay\">\n            <div class=\"score-display\">\n                <div id=\"score\">Score: 0</div>\n                <div id=\"timer\">Time: 0s</div>\n                <div id=\"level\">Level: 1</div>\n            </div>\n        </div>\n        \n        <!-- Start Screen -->\n        <div id=\"startScreen\" class=\"screen\">\n            <h1>üöÄ Galaxy Defender</h1>\n            <p>Pilot your rocket to avoid asteroids and UFOs while collecting stars!</p>\n            <div class=\"instructions\">\n                <p>üöÄ Move your mouse to control the rocket</p>\n                <p>‚≠ê Collect stars for 50 points each</p>\n                <p>‚òÑÔ∏è Avoid asteroids and UFOs</p>\n                <p>üéØ Survive as long as possible!</p>\n            </div>\n            <button id=\"startButton\" class=\"game-button\">Start Game</button>\n        </div>\n        \n        <!-- Game Over Screen -->\n        <div id=\"gameOverScreen\" class=\"screen hidden\">\n            <h1>Game Over!</h1>\n            <div id=\"finalStats\">\n                <p id=\"finalScore\">Final Score: 0</p>\n                <p id=\"finalTime\">Time Survived: 0s</p>\n                <p id=\"finalLevel\">Level Reached: 1</p>\n            </div>\n            <button id=\"restartButton\" class=\"game-button\">Play Again</button>\n        </div>\n        \n        <!-- Pause Screen -->\n        <div id=\"pauseScreen\" class=\"screen hidden\">\n            <h1>Game Paused</h1>\n            <p>Press SPACE to resume</p>\n            <button id=\"resumeButton\" class=\"game-button\">Resume</button>\n        </div>\n    </div>\n    \n    <div class=\"controls-info\">\n        <p>Controls: Move mouse to pilot rocket | SPACE to pause</p>\n    </div>\n\n    <!-- Load all JavaScript modules in correct order -->\n    <script src=\"game.js\"></script>\n    <script src=\"player.js\"></script>\n    <script src=\"objects.js\"></script>\n    <script src=\"collision.js\"></script>\n    <script src=\"scoring.js\"></script>\n    <script src=\"gameOver.js\"></script>\n    <script src=\"difficulty.js\"></script>\n    <script src=\"ui.js\"></script>\n    <script src=\"main.js\"></script>\n</body>\n</html>"
    },
    {
      "name": "styles.css",
      "path": "styles.css",
      "language": "css",
      "content": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Arial', sans-serif;\n    background: linear-gradient(135deg, #0c0c2e 0%, #1a1a3e 50%, #2d1b69 100%);\n    color: white;\n    overflow: hidden;\n    height: 100vh;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n}\n\n.game-container {\n    position: relative;\n    border: 3px solid #4a90e2;\n    border-radius: 10px;\n    box-shadow: 0 0 30px rgba(74, 144, 226, 0.5);\n    background: #000;\n}\n\n#gameCanvas {\n    display: block;\n    background: linear-gradient(180deg, #000428 0%, #004e92 100%);\n    cursor: none;\n}\n\n.ui-overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    pointer-events: none;\n    z-index: 10;\n}\n\n.score-display {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 15px 20px;\n    background: rgba(0, 0, 0, 0.7);\n    border-bottom: 2px solid #4a90e2;\n    font-size: 18px;\n    font-weight: bold;\n    text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);\n}\n\n.screen {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: rgba(0, 0, 0, 0.9);\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n    text-align: center;\n    z-index: 100;\n    backdrop-filter: blur(5px);\n}\n\n.screen.hidden {\n    display: none;\n}\n\n.screen h1 {\n    font-size: 3em;\n    margin-bottom: 20px;\n    text-shadow: 0 0 20px rgba(74, 144, 226, 0.8);\n    animation: glow 2s ease-in-out infinite alternate;\n}\n\n@keyframes glow {\n    from { text-shadow: 0 0 20px rgba(74, 144, 226, 0.8); }\n    to { text-shadow: 0 0 30px rgba(74, 144, 226, 1), 0 0 40px rgba(74, 144, 226, 0.8); }\n}\n\n.instructions {\n    margin: 20px 0;\n    font-size: 1.2em;\n    line-height: 1.6;\n}\n\n.instructions p {\n    margin: 10px 0;\n    padding: 5px 15px;\n    background: rgba(74, 144, 226, 0.2);\n    border-radius: 20px;\n    border: 1px solid rgba(74, 144, 226, 0.3);\n}\n\n.game-button {\n    background: linear-gradient(45deg, #4a90e2, #357abd);\n    color: white;\n    border: none;\n    padding: 15px 30px;\n    font-size: 1.3em;\n    font-weight: bold;\n    border-radius: 25px;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    box-shadow: 0 5px 15px rgba(74, 144, 226, 0.4);\n    text-transform: uppercase;\n    letter-spacing: 1px;\n}\n\n.game-button:hover {\n    background: linear-gradient(45deg, #357abd, #2968a3);\n    transform: translateY(-2px);\n    box-shadow: 0 8px 25px rgba(74, 144, 226, 0.6);\n}\n\n.game-button:active {\n    transform: translateY(0);\n}\n\n#finalStats {\n    margin: 20px 0;\n    font-size: 1.3em;\n    line-height: 1.8;\n}\n\n#finalStats p {\n    margin: 10px 0;\n    padding: 10px 20px;\n    background: rgba(74, 144, 226, 0.2);\n    border-radius: 10px;\n    border-left: 4px solid #4a90e2;\n}\n\n.controls-info {\n    margin-top: 20px;\n    text-align: center;\n    font-size: 0.9em;\n    opacity: 0.8;\n    background: rgba(0, 0, 0, 0.5);\n    padding: 10px 20px;\n    border-radius: 20px;\n    border: 1px solid rgba(74, 144, 226, 0.3);\n}\n\n/* Notification animations */\n@keyframes slideDown {\n    from { transform: translateX(-50%) translateY(-100%); opacity: 0; }\n    to { transform: translateX(-50%) translateY(0); opacity: 1; }\n}\n\n@keyframes slideUp {\n    from { transform: translateX(-50%) translateY(0); opacity: 1; }\n    to { transform: translateX(-50%) translateY(-100%); opacity: 0; }\n}\n\n/* Responsive Design */\n@media (max-width: 900px) {\n    #gameCanvas {\n        width: 90vw;\n        height: 67.5vw;\n        max-height: 70vh;\n    }\n    \n    .screen h1 {\n        font-size: 2em;\n    }\n    \n    .instructions {\n        font-size: 1em;\n    }\n    \n    .score-display {\n        font-size: 14px;\n        padding: 10px 15px;\n    }\n}\n\n@media (max-width: 600px) {\n    .screen h1 {\n        font-size: 1.5em;\n    }\n    \n    .instructions {\n        font-size: 0.9em;\n    }\n    \n    .game-button {\n        padding: 12px 25px;\n        font-size: 1.1em;\n    }\n}"
    },
    {
      "name": "game.js",
      "path": "game.js",
      "language": "javascript",
      "content": "/**\n * Game Engine Foundation\n * Handles core game loop, canvas management, and state control\n */\n\nclass GameEngine {\n    constructor(canvasId) {\n        this.canvas = document.getElementById(canvasId);\n        this.ctx = this.canvas.getContext('2d');\n        \n        if (!this.ctx) {\n            throw new Error('Failed to get canvas context');\n        }\n        \n        // Game state management\n        this.gameState = 'start'; // 'start', 'playing', 'paused', 'gameOver'\n        this.lastTime = 0;\n        this.deltaTime = 0;\n        \n        // Game entities\n        this.particles = [];\n        \n        // Game timing\n        this.startTime = 0;\n        this.gameTime = 0;\n        \n        // Initialize background stars for animation\n        this.backgroundStars = this.initializeBackgroundStars();\n    }\n    \n    /**\n     * Initialize background stars for animated starfield\n     */\n    initializeBackgroundStars() {\n        const stars = [];\n        for (let i = 0; i < 100; i++) {\n            stars.push({\n                x: Math.random() * this.canvas.width,\n                y: Math.random() * this.canvas.height,\n                size: Math.random() * 2 + 0.5,\n                speed: Math.random() * 0.5 + 0.1,\n                opacity: Math.random() * 0.8 + 0.2\n            });\n        }\n        return stars;\n    }\n    \n    /**\n     * Update game timing\n     */\n    updateTiming(currentTime) {\n        this.deltaTime = currentTime - this.lastTime;\n        this.lastTime = currentTime;\n        \n        if (this.gameState === 'playing') {\n            this.gameTime = currentTime - this.startTime;\n        }\n    }\n    \n    /**\n     * Update particle effects\n     */\n    updateParticles() {\n        for (let i = this.particles.length - 1; i >= 0; i--) {\n            const particle = this.particles[i];\n            \n            particle.x += particle.vx;\n            particle.y += particle.vy;\n            particle.life -= this.deltaTime;\n            particle.alpha = Math.max(0, particle.life / particle.maxLife);\n            \n            if (particle.life <= 0) {\n                this.particles.splice(i, 1);\n            }\n        }\n    }\n    \n    /**\n     * Update background stars animation\n     */\n    updateBackground() {\n        this.backgroundStars.forEach(star => {\n            star.y += star.speed;\n            if (star.y > this.canvas.height) {\n                star.y = -5;\n                star.x = Math.random() * this.canvas.width;\n            }\n        });\n    }\n    \n    /**\n     * Clear the canvas\n     */\n    clearCanvas() {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n    \n    /**\n     * Render animated starfield background\n     */\n    renderBackground() {\n        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n        \n        this.backgroundStars.forEach(star => {\n            this.ctx.save();\n            this.ctx.globalAlpha = star.opacity;\n            this.ctx.beginPath();\n            this.ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n            this.ctx.fill();\n            this.ctx.restore();\n        });\n    }\n    \n    /**\n     * Render particle effects\n     */\n    renderParticles() {\n        this.particles.forEach(particle => {\n            this.ctx.save();\n            this.ctx.globalAlpha = particle.alpha;\n            this.ctx.fillStyle = particle.color;\n            this.ctx.beginPath();\n            this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);\n            this.ctx.fill();\n            this.ctx.restore();\n        });\n    }\n    \n    /**\n     * Add particle effect\n     */\n    addParticle(x, y, vx, vy, life, color, size) {\n        this.particles.push({\n            x: x,\n            y: y,\n            vx: vx,\n            vy: vy,\n            life: life,\n            maxLife: life,\n            alpha: 1,\n            color: color,\n            size: size\n        });\n    }\n    \n    /**\n     * Create explosion effect\n     */\n    createExplosion(x, y, count = 20) {\n        for (let i = 0; i < count; i++) {\n            this.addParticle(\n                x, y,\n                (Math.random() - 0.5) * 10,\n                (Math.random() - 0.5) * 10,\n                1000,\n                `hsl(${Math.random() * 60}, 100%, 50%)`,\n                Math.random() * 4 + 2\n            );\n        }\n    }\n    \n    /**\n     * Create collection effect\n     */\n    createCollectEffect(x, y, count = 10) {\n        for (let i = 0; i < count; i++) {\n            this.addParticle(\n                x, y,\n                (Math.random() - 0.5) * 5,\n                (Math.random() - 0.5) * 5,\n                500,\n                '#FFD700',\n                Math.random() * 3 + 1\n            );\n        }\n    }\n    \n    /**\n     * Create level up effect\n     */\n    createLevelUpEffect() {\n        for (let i = 0; i < 30; i++) {\n            this.addParticle(\n                this.canvas.width / 2,\n                this.canvas.height / 2,\n                (Math.random() - 0.5) * 15,\n                (Math.random() - 0.5) * 15,\n                2000,\n                '#4a90e2',\n                Math.random() * 5 + 2\n            );\n        }\n    }\n}"
    },
    {
      "name": "player.js",
      "path": "player.js",
      "language": "javascript",
      "content": "/**\n * Player Rocket Entity\n * Handles player movement, rendering, and mouse tracking\n */\n\nclass Player {\n    constructor(canvas) {\n        this.canvas = canvas;\n        this.x = canvas.width / 2;\n        this.y = canvas.height - 80;\n        this.width = 40;\n        this.height = 40;\n        this.emoji = 'üöÄ';\n        this.speed = 8;\n        \n        // Mouse tracking\n        this.mouseX = canvas.width / 2;\n        this.mouseY = canvas.height / 2;\n        \n        this.initializeControls();\n    }\n    \n    /**\n     * Initialize mouse controls\n     */\n    initializeControls() {\n        this.canvas.addEventListener('mousemove', (e) => {\n            const rect = this.canvas.getBoundingClientRect();\n            const scaleX = this.canvas.width / rect.width;\n            const scaleY = this.canvas.height / rect.height;\n            \n            this.mouseX = (e.clientX - rect.left) * scaleX;\n            this.mouseY = (e.clientY - rect.top) * scaleY;\n        });\n        \n        // Handle touch events for mobile\n        this.canvas.addEventListener('touchmove', (e) => {\n            e.preventDefault();\n            const rect = this.canvas.getBoundingClientRect();\n            const scaleX = this.canvas.width / rect.width;\n            const scaleY = this.canvas.height / rect.height;\n            \n            const touch = e.touches[0];\n            this.mouseX = (touch.clientX - rect.left) * scaleX;\n            this.mouseY = (touch.clientY - rect.top) * scaleY;\n        });\n    }\n    \n    /**\n     * Update player position based on mouse movement\n     */\n    update() {\n        // Smooth movement towards mouse position (horizontal only)\n        const targetX = this.mouseX - this.width / 2;\n        const dx = targetX - this.x;\n        this.x += dx * 0.15; // Smooth interpolation\n        \n        // Keep player within canvas bounds\n        this.x = Math.max(0, Math.min(this.canvas.width - this.width, this.x));\n    }\n    \n    /**\n     * Render the player rocket\n     */\n    render(ctx) {\n        ctx.font = '40px Arial';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        \n        // Add glow effect\n        ctx.shadowColor = '#4a90e2';\n        ctx.shadowBlur = 10;\n        \n        ctx.fillText(\n            this.emoji,\n            this.x + this.width / 2,\n            this.y + this.height / 2\n        );\n        \n        ctx.shadowBlur = 0;\n    }\n    \n    /**\n     * Reset player to initial position\n     */\n    reset() {\n        this.x = this.canvas.width / 2;\n        this.y = this.canvas.height - 80;\n        this.mouseX = this.canvas.width / 2;\n        this.mouseY = this.canvas.height / 2;\n    }\n    \n    /**\n     * Get player bounds for collision detection\n     */\n    getBounds() {\n        return {\n            x: this.x,\n            y: this.y,\n            width: this.width,\n            height: this.height\n        };\n    }\n}"
    },
    {
      "name": "objects.js",
      "path": "objects.js",
      "language": "javascript",
      "content": "/**\n * Falling Objects System\n * Manages spawning and updating of stars, asteroids, and UFOs\n */\n\nclass ObjectManager {\n    constructor(canvas) {\n        this.canvas = canvas;\n        this.objects = [];\n        \n        // Spawning configuration\n        this.lastSpawn = 0;\n        this.spawnInterval = 1500; // Base spawn interval in milliseconds\n        this.minSpawnInterval = 500; // Minimum spawn interval\n        \n        // Object types configuration\n        this.objectTypes = {\n            star: {\n                emoji: '‚≠ê',\n                isGood: true,\n                probability: 0.3,\n                points: 50\n            },\n            asteroid: {\n                emoji: '‚òÑÔ∏è',\n                isGood: false,\n                probability: 0.35\n            },\n            ufo: {\n                emoji: 'üõ∏',\n                isGood: false,\n                probability: 0.35\n            }\n        };\n    }\n    \n    /**\n     * Update spawn interval based on difficulty\n     */\n    updateSpawnRate(level) {\n        this.spawnInterval = Math.max(\n            this.minSpawnInterval,\n            1500 - (level - 1) * 100\n        );\n    }\n    \n    /**\n     * Spawn a new falling object\n     */\n    spawnObject(currentSpeed) {\n        const now = Date.now();\n        if (now - this.lastSpawn < this.spawnInterval) return;\n        \n        this.lastSpawn = now;\n        \n        // Determine object type based on probability\n        const rand = Math.random();\n        let type, config;\n        \n        if (rand < this.objectTypes.star.probability) {\n            type = 'star';\n            config = this.objectTypes.star;\n        } else if (rand < this.objectTypes.star.probability + this.objectTypes.asteroid.probability) {\n            type = 'asteroid';\n            config = this.objectTypes.asteroid;\n        } else {\n            type = 'ufo';\n            config = this.objectTypes.ufo;\n        }\n        \n        const object = {\n            x: Math.random() * (this.canvas.width - 40),\n            y: -40,\n            width: 35,\n            height: 35,\n            emoji: config.emoji,\n            type: type,\n            isGood: config.isGood,\n            points: config.points || 0,\n            speed: currentSpeed + Math.random() * 2,\n            rotation: 0,\n            rotationSpeed: (Math.random() - 0.5) * 0.1\n        };\n        \n        this.objects.push(object);\n    }\n    \n    /**\n     * Update all falling objects\n     */\n    update() {\n        for (let i = this.objects.length - 1; i >= 0; i--) {\n            const obj = this.objects[i];\n            \n            // Update position and rotation\n            obj.y += obj.speed;\n            obj.rotation += obj.rotationSpeed;\n            \n            // Remove objects that are off-screen\n            if (obj.y > this.canvas.height + 50) {\n                this.objects.splice(i, 1);\n            }\n        }\n    }\n    \n    /**\n     * Render all falling objects\n     */\n    render(ctx) {\n        ctx.font = '35px Arial';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        \n        this.objects.forEach(obj => {\n            ctx.save();\n            \n            // Apply rotation for visual effect\n            ctx.translate(obj.x + obj.width / 2, obj.y + obj.height / 2);\n            ctx.rotate(obj.rotation);\n            \n            // Add appropriate glow effect\n            if (obj.isGood) {\n                ctx.shadowColor = '#FFD700';\n                ctx.shadowBlur = 8;\n            } else {\n                ctx.shadowColor = '#FF4444';\n                ctx.shadowBlur = 6;\n            }\n            \n            ctx.fillText(obj.emoji, 0, 0);\n            \n            ctx.restore();\n        });\n        \n        ctx.shadowBlur = 0;\n    }\n    \n    /**\n     * Get all objects for collision detection\n     */\n    getObjects() {\n        return this.objects;\n    }\n    \n    /**\n     * Remove object by index\n     */\n    removeObject(index) {\n        if (index >= 0 && index < this.objects.length) {\n            return this.objects.splice(index, 1)[0];\n        }\n        return null;\n    }\n    \n    /**\n     * Clear all objects\n     */\n    clear() {\n        this.objects = [];\n    }\n    \n    /**\n     * Get object count\n     */\n    getCount() {\n        return this.objects.length;\n    }\n}"
    },
    {
      "name": "collision.js",
      "path": "collision.js",
      "language": "javascript",
      "content": "/**\n * Collision Detection System\n * Handles collision detection between player and falling objects\n */\n\nclass CollisionDetector {\n    constructor() {\n        // Collision detection configuration\n        this.collisionPadding = 5; // Pixels to reduce hitbox for better gameplay feel\n    }\n    \n    /**\n     * Check collision between two rectangular objects\n     */\n    checkCollision(rect1, rect2) {\n        const padding = this.collisionPadding;\n        \n        return (rect1.x + padding) < (rect2.x + rect2.width - padding) &&\n               (rect1.x + rect1.width - padding) > (rect2.x + padding) &&\n               (rect1.y + padding) < (rect2.y + rect2.height - padding) &&\n               (rect1.y + rect1.height - padding) > (rect2.y + padding);\n    }\n    \n    /**\n     * Check collision between player and all objects\n     * Returns array of collision results\n     */\n    checkPlayerCollisions(player, objects) {\n        const collisions = [];\n        const playerBounds = player.getBounds();\n        \n        for (let i = 0; i < objects.length; i++) {\n            const obj = objects[i];\n            \n            if (this.checkCollision(playerBounds, obj)) {\n                collisions.push({\n                    index: i,\n                    object: obj,\n                    type: obj.type,\n                    isGood: obj.isGood,\n                    points: obj.points || 0\n                });\n            }\n        }\n        \n        return collisions;\n    }\n    \n    /**\n     * Check if point is inside rectangle\n     */\n    pointInRect(x, y, rect) {\n        return x >= rect.x && \n               x <= rect.x + rect.width && \n               y >= rect.y && \n               y <= rect.y + rect.height;\n    }\n    \n    /**\n     * Calculate distance between two points\n     */\n    distance(x1, y1, x2, y2) {\n        const dx = x2 - x1;\n        const dy = y2 - y1;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    \n    /**\n     * Check circular collision (alternative collision method)\n     */\n    checkCircularCollision(obj1, obj2, radius1, radius2) {\n        const centerX1 = obj1.x + obj1.width / 2;\n        const centerY1 = obj1.y + obj1.height / 2;\n        const centerX2 = obj2.x + obj2.width / 2;\n        const centerY2 = obj2.y + obj2.height / 2;\n        \n        const distance = this.distance(centerX1, centerY1, centerX2, centerY2);\n        return distance < (radius1 + radius2);\n    }\n}"
    },
    {
      "name": "scoring.js",
      "path": "scoring.js",
      "language": "javascript",
      "content": "/**\n * Scoring System\n * Manages game score and related statistics\n */\n\nclass ScoreManager {\n    constructor() {\n        this.score = 0;\n        this.highScore = this.loadHighScore();\n        this.starsCollected = 0;\n        this.totalObjects = 0;\n    }\n    \n    /**\n     * Add points to the score\n     */\n    addScore(points) {\n        if (points > 0) {\n            this.score += points;\n            this.starsCollected++;\n            \n            // Update high score if necessary\n            if (this.score > this.highScore) {\n                this.highScore = this.score;\n                this.saveHighScore();\n            }\n            \n            return true;\n        }\n        return false;\n    }\n    \n    /**\n     * Get current score\n     */\n    getScore() {\n        return this.score;\n    }\n    \n    /**\n     * Get high score\n     */\n    getHighScore() {\n        return this.highScore;\n    }\n    \n    /**\n     * Reset score for new game\n     */\n    reset() {\n        this.score = 0;\n        this.starsCollected = 0;\n        this.totalObjects = 0;\n    }\n    \n    /**\n     * Get game statistics\n     */\n    getStats() {\n        return {\n            score: this.score,\n            highScore: this.highScore,\n            starsCollected: this.starsCollected,\n            totalObjects: this.totalObjects,\n            accuracy: this.totalObjects > 0 ? (this.starsCollected / this.totalObjects * 100).toFixed(1) : 0\n        };\n    }\n    \n    /**\n     * Increment total objects counter\n     */\n    incrementTotalObjects() {\n        this.totalObjects++;\n    }\n    \n    /**\n     * Load high score from localStorage\n     */\n    loadHighScore() {\n        try {\n            const saved = localStorage.getItem('galaxyDefenderHighScore');\n            return saved ? parseInt(saved, 10) : 0;\n        } catch (error) {\n            console.warn('Could not load high score:', error);\n            return 0;\n        }\n    }\n    \n    /**\n     * Save high score to localStorage\n     */\n    saveHighScore() {\n        try {\n            localStorage.setItem('galaxyDefenderHighScore', this.highScore.toString());\n        } catch (error) {\n            console.warn('Could not save high score:', error);\n        }\n    }\n    \n    /**\n     * Calculate bonus points based on performance\n     */\n    calculateTimeBonus(timeInSeconds) {\n        return Math.floor(timeInSeconds / 10) * 10; // 10 points per 10 seconds survived\n    }\n    \n    /**\n     * Calculate level completion bonus\n     */\n    calculateLevelBonus(level) {\n        return level * 100; // 100 points per level completed\n    }\n}"
    },
    {
      "name": "gameOver.js",
      "path": "gameOver.js",
      "language": "javascript",
      "content": "/**\n * Game Over System\n * Handles game over logic, final score calculation, and restart functionality\n */\n\nclass GameOverManager {\n    constructor(scoreManager) {\n        this.scoreManager = scoreManager;\n        this.gameOverCallbacks = [];\n        this.isGameOver = false;\n    }\n    \n    /**\n     * Trigger game over\n     */\n    triggerGameOver(player, gameTime, level) {\n        if (this.isGameOver) return; // Prevent multiple game over triggers\n        \n        this.isGameOver = true;\n        \n        // Calculate final statistics\n        const timeInSeconds = Math.floor(gameTime / 1000);\n        const stats = this.scoreManager.getStats();\n        \n        // Calculate bonus points\n        const timeBonus = this.scoreManager.calculateTimeBonus(timeInSeconds);\n        const levelBonus = this.scoreManager.calculateLevelBonus(level);\n        \n        const finalStats = {\n            score: stats.score,\n            timeBonus: timeBonus,\n            levelBonus: levelBonus,\n            finalScore: stats.score + timeBonus + levelBonus,\n            timeSurvived: timeInSeconds,\n            level: level,\n            starsCollected: stats.starsCollected,\n            accuracy: stats.accuracy,\n            highScore: stats.highScore,\n            isNewHighScore: (stats.score + timeBonus + levelBonus) > stats.highScore\n        };\n        \n        // Update final score if bonuses were earned\n        if (timeBonus > 0 || levelBonus > 0) {\n            this.scoreManager.addScore(timeBonus + levelBonus);\n        }\n        \n        // Execute all registered callbacks\n        this.gameOverCallbacks.forEach(callback => {\n            try {\n                callback(finalStats);\n            } catch (error) {\n                console.error('Error in game over callback:', error);\n            }\n        });\n        \n        return finalStats;\n    }\n    \n    /**\n     * Register callback for game over event\n     */\n    onGameOver(callback) {\n        if (typeof callback === 'function') {\n            this.gameOverCallbacks.push(callback);\n        }\n    }\n    \n    /**\n     * Reset game over state\n     */\n    reset() {\n        this.isGameOver = false;\n    }\n    \n    /**\n     * Check if game is over\n     */\n    getGameOverState() {\n        return this.isGameOver;\n    }\n    \n    /**\n     * Handle collision with bad object\n     */\n    handleBadCollision(collisionData, player, gameTime, level) {\n        console.log(`Game over! Hit ${collisionData.type}`);\n        return this.triggerGameOver(player, gameTime, level);\n    }\n    \n    /**\n     * Format time for display\n     */\n    formatTime(seconds) {\n        const minutes = Math.floor(seconds / 60);\n        const remainingSeconds = seconds % 60;\n        \n        if (minutes > 0) {\n            return `${minutes}m ${remainingSeconds}s`;\n        }\n        return `${remainingSeconds}s`;\n    }\n    \n    /**\n     * Get game over message based on performance\n     */\n    getGameOverMessage(stats) {\n        if (stats.isNewHighScore) {\n            return \"üéâ NEW HIGH SCORE! üéâ\";\n        } else if (stats.level >= 10) {\n            return \"üåü Excellent Performance! üåü\";\n        } else if (stats.level >= 5) {\n            return \"üëç Good Job! üëç\";\n        } else if (stats.starsCollected >= 10) {\n            return \"‚≠ê Star Collector! ‚≠ê\";\n        } else {\n            return \"üí• Game Over! üí•\";\n        }\n    }\n}"
    },
    {
      "name": "difficulty.js",
      "path": "difficulty.js",
      "language": "javascript",
      "content": "/**\n * Progressive Difficulty System\n * Manages game speed increases and difficulty scaling over time\n */\n\nclass DifficultyManager {\n    constructor() {\n        // Base difficulty settings\n        this.baseSpeed = 2;\n        this.currentSpeed = this.baseSpeed;\n        this.speedMultiplier = 1;\n        \n        // Difficulty progression\n        this.level = 1;\n        this.lastDifficultyIncrease = 0;\n        this.difficultyInterval = 10000; // 10 seconds in milliseconds\n        \n        // Speed scaling configuration\n        this.speedIncrement = 0.2;\n        this.maxSpeedMultiplier = 5.0; // Cap the maximum speed\n        \n        // Callbacks for difficulty changes\n        this.difficultyChangeCallbacks = [];\n    }\n    \n    /**\n     * Update difficulty based on game time\n     */\n    update(gameTime) {\n        const timeSinceLastIncrease = gameTime - this.lastDifficultyIncrease;\n        \n        if (timeSinceLastIncrease >= this.difficultyInterval) {\n            this.increaseDifficulty(gameTime);\n            return true; // Difficulty increased\n        }\n        \n        return false; // No change\n    }\n    \n    /**\n     * Increase game difficulty\n     */\n    increaseDifficulty(gameTime) {\n        this.lastDifficultyIncrease = gameTime;\n        \n        // Increase speed multiplier with cap\n        if (this.speedMultiplier < this.maxSpeedMultiplier) {\n            this.speedMultiplier += this.speedIncrement;\n            this.currentSpeed = this.baseSpeed * this.speedMultiplier;\n        }\n        \n        // Increase level\n        this.level = Math.floor(gameTime / this.difficultyInterval) + 1;\n        \n        // Notify callbacks about difficulty change\n        const difficultyData = {\n            level: this.level,\n            speed: this.currentSpeed,\n            speedMultiplier: this.speedMultiplier,\n            gameTime: gameTime\n        };\n        \n        this.difficultyChangeCallbacks.forEach(callback => {\n            try {\n                callback(difficultyData);\n            } catch (error) {\n                console.error('Error in difficulty change callback:', error);\n            }\n        });\n        \n        console.log(`Difficulty increased! Level: ${this.level}, Speed: ${this.currentSpeed.toFixed(2)}`);\n    }\n    \n    /**\n     * Register callback for difficulty changes\n     */\n    onDifficultyChange(callback) {\n        if (typeof callback === 'function') {\n            this.difficultyChangeCallbacks.push(callback);\n        }\n    }\n    \n    /**\n     * Get current difficulty level\n     */\n    getLevel() {\n        return this.level;\n    }\n    \n    /**\n     * Get current speed\n     */\n    getCurrentSpeed() {\n        return this.currentSpeed;\n    }\n    \n    /**\n     * Get speed multiplier\n     */\n    getSpeedMultiplier() {\n        return this.speedMultiplier;\n    }\n    \n    /**\n     * Reset difficulty to initial state\n     */\n    reset() {\n        this.level = 1;\n        this.speedMultiplier = 1;\n        this.currentSpeed = this.baseSpeed;\n        this.lastDifficultyIncrease = 0;\n    }\n    \n    /**\n     * Get time until next difficulty increase\n     */\n    getTimeUntilNextIncrease(gameTime) {\n        const timeSinceLastIncrease = gameTime - this.lastDifficultyIncrease;\n        return Math.max(0, this.difficultyInterval - timeSinceLastIncrease);\n    }\n    \n    /**\n     * Get difficulty progress (0-1)\n     */\n    getDifficultyProgress(gameTime) {\n        const timeSinceLastIncrease = gameTime - this.lastDifficultyIncrease;\n        return Math.min(1, timeSinceLastIncrease / this.difficultyInterval);\n    }\n    \n    /**\n     * Calculate spawn rate based on difficulty\n     */\n    getSpawnRate() {\n        const baseSpawnInterval = 1500;\n        const minSpawnInterval = 500;\n        \n        return Math.max(\n            minSpawnInterval,\n            baseSpawnInterval - (this.level - 1) * 100\n        );\n    }\n}"
    },
    {
      "name": "ui.js",
      "path": "ui.js",
      "language": "javascript",
      "content": "/**\n * User Interface System\n * Manages all UI elements, screens, and user interactions\n */\n\nclass UIManager {\n    constructor() {\n        this.elements = {\n            startScreen: document.getElementById('startScreen'),\n            gameOverScreen: document.getElementById('gameOverScreen'),\n            pauseScreen: document.getElementById('pauseScreen'),\n            gameUI: document.getElementById('gameUI'),\n            score: document.getElementById('score'),\n            timer: document.getElementById('timer'),\n            level: document.getElementById('level'),\n            finalScore: document.getElementById('finalScore'),\n            finalTime: document.getElementById('finalTime'),\n            finalLevel: document.getElementById('finalLevel'),\n            startButton: document.getElementById('startButton'),\n            restartButton: document.getElementById('restartButton'),\n            resumeButton: document.getElementById('resumeButton')\n        };\n        \n        // Validate all required elements exist\n        this.validateElements();\n        \n        // UI state\n        this.currentScreen = 'start';\n        \n        // Button callbacks\n        this.buttonCallbacks = {\n            start: [],\n            restart: [],\n            resume: [],\n            pause: []\n        };\n        \n        this.initializeEventListeners();\n    }\n    \n    /**\n     * Validate that all required UI elements exist\n     */\n    validateElements() {\n        const missingElements = [];\n        \n        Object.entries(this.elements).forEach(([key, element]) => {\n            if (!element) {\n                missingElements.push(key);\n            }\n        });\n        \n        if (missingElements.length > 0) {\n            throw new Error(`Missing UI elements: ${missingElements.join(', ')}`);\n        }\n    }\n    \n    /**\n     * Initialize UI event listeners\n     */\n    initializeEventListeners() {\n        // Start button\n        this.elements.startButton.addEventListener('click', () => {\n            this.executeCallbacks('start');\n        });\n        \n        // Restart button\n        this.elements.restartButton.addEventListener('click', () => {\n            this.executeCallbacks('restart');\n        });\n        \n        // Resume button\n        this.elements.resumeButton.addEventListener('click', () => {\n            this.executeCallbacks('resume');\n        });\n        \n        // Keyboard shortcuts\n        document.addEventListener('keydown', (e) => {\n            switch(e.code) {\n                case 'Space':\n                    e.preventDefault();\n                    this.handleSpaceKey();\n                    break;\n                case 'Escape':\n                    this.handleEscapeKey();\n                    break;\n                case 'Enter':\n                    this.handleEnterKey();\n                    break;\n            }\n        });\n    }\n    \n    /**\n     * Handle space key based on current screen\n     */\n    handleSpaceKey() {\n        switch(this.currentScreen) {\n            case 'start':\n                this.executeCallbacks('start');\n                break;\n            case 'playing':\n                this.executeCallbacks('pause');\n                break;\n            case 'paused':\n                this.executeCallbacks('resume');\n                break;\n            case 'gameOver':\n                this.executeCallbacks('restart');\n                break;\n        }\n    }\n    \n    /**\n     * Handle escape key\n     */\n    handleEscapeKey() {\n        if (this.currentScreen === 'playing') {\n            this.executeCallbacks('pause');\n        }\n    }\n    \n    /**\n     * Handle enter key\n     */\n    handleEnterKey() {\n        if (this.currentScreen === 'start' || this.currentScreen === 'gameOver') {\n            this.executeCallbacks(this.currentScreen === 'start' ? 'start' : 'restart');\n        }\n    }\n    \n    /**\n     * Show start screen\n     */\n    showStartScreen() {\n        this.hideAllScreens();\n        this.elements.startScreen.classList.remove('hidden');\n        this.currentScreen = 'start';\n    }\n    \n    /**\n     * Show game UI (playing state)\n     */\n    showGameUI() {\n        this.hideAllScreens();\n        this.elements.gameUI.style.display = 'block';\n        this.currentScreen = 'playing';\n    }\n    \n    /**\n     * Show pause screen\n     */\n    showPauseScreen() {\n        this.elements.pauseScreen.classList.remove('hidden');\n        this.currentScreen = 'paused';\n    }\n    \n    /**\n     * Show game over screen with final statistics\n     */\n    showGameOverScreen(stats) {\n        this.hideAllScreens();\n        \n        // Clear any previous additional stats\n        const finalStatsDiv = document.getElementById('finalStats');\n        const existingAdditionalStats = finalStatsDiv.querySelector('.additional-stats');\n        if (existingAdditionalStats) {\n            existingAdditionalStats.remove();\n        }\n        \n        // Update final statistics\n        this.elements.finalScore.textContent = `Final Score: ${stats.finalScore || stats.score}`;\n        this.elements.finalTime.textContent = `Time Survived: ${stats.timeSurvived}s`;\n        this.elements.finalLevel.textContent = `Level Reached: ${stats.level}`;\n        \n        // Add additional stats if available\n        if (stats.starsCollected !== undefined) {\n            const additionalStats = document.createElement('p');\n            additionalStats.className = 'additional-stats';\n            additionalStats.textContent = `Stars Collected: ${stats.starsCollected}`;\n            additionalStats.style.margin = '10px 0';\n            additionalStats.style.padding = '10px 20px';\n            additionalStats.style.background = 'rgba(74, 144, 226, 0.2)';\n            additionalStats.style.borderRadius = '10px';\n            additionalStats.style.borderLeft = '4px solid #4a90e2';\n            \n            finalStatsDiv.appendChild(additionalStats);\n        }\n        \n        this.elements.gameOverScreen.classList.remove('hidden');\n        this.currentScreen = 'gameOver';\n    }\n    \n    /**\n     * Hide all screens\n     */\n    hideAllScreens() {\n        this.elements.startScreen.classList.add('hidden');\n        this.elements.gameOverScreen.classList.add('hidden');\n        this.elements.pauseScreen.classList.add('hidden');\n        this.elements.gameUI.style.display = 'none';\n    }\n    \n    /**\n     * Update score display\n     */\n    updateScore(score) {\n        this.elements.score.textContent = `Score: ${score}`;\n    }\n    \n    /**\n     * Update timer display\n     */\n    updateTimer(timeInSeconds) {\n        this.elements.timer.textContent = `Time: ${timeInSeconds}s`;\n    }\n    \n    /**\n     * Update level display\n     */\n    updateLevel(level) {\n        this.elements.level.textContent = `Level: ${level}`;\n    }\n    \n    /**\n     * Register callback for button events\n     */\n    onButtonClick(buttonType, callback) {\n        if (this.buttonCallbacks[buttonType] && typeof callback === 'function') {\n            this.buttonCallbacks[buttonType].push(callback);\n        }\n    }\n    \n    /**\n     * Execute callbacks for button type\n     */\n    executeCallbacks(buttonType) {\n        if (this.buttonCallbacks[buttonType]) {\n            this.buttonCallbacks[buttonType].forEach(callback => {\n                try {\n                    callback();\n                } catch (error) {\n                    console.error(`Error in ${buttonType} callback:`, error);\n                }\n            });\n        }\n    }\n    \n    /**\n     * Show notification message\n     */\n    showNotification(message, duration = 3000) {\n        const notification = document.createElement('div');\n        notification.textContent = message;\n        notification.style.cssText = `\n            position: fixed;\n            top: 20px;\n            left: 50%;\n            transform: translateX(-50%);\n            background: rgba(74, 144, 226, 0.9);\n            color: white;\n            padding: 15px 25px;\n            border-radius: 25px;\n            font-weight: bold;\n            z-index: 1000;\n            animation: slideDown 0.3s ease-out;\n        `;\n        \n        document.body.appendChild(notification);\n        \n        setTimeout(() => {\n            notification.style.animation = 'slideUp 0.3s ease-in';\n            setTimeout(() => {\n                if (notification.parentNode) {\n                    notification.parentNode.removeChild(notification);\n                }\n            }, 300);\n        }, duration);\n    }\n    \n    /**\n     * Add CSS animations for notifications\n     */\n    addNotificationStyles() {\n        if (!document.getElementById('notification-styles')) {\n            const style = document.createElement('style');\n            style.id = 'notification-styles';\n            style.textContent = `\n                @keyframes slideDown {\n                    from { transform: translateX(-50%) translateY(-100%); opacity: 0; }\n                    to { transform: translateX(-50%) translateY(0); opacity: 1; }\n                }\n                @keyframes slideUp {\n                    from { transform: translateX(-50%) translateY(0); opacity: 1; }\n                    to { transform: translateX(-50%) translateY(-100%); opacity: 0; }\n                }\n            `;\n            document.head.appendChild(style);\n        }\n    }\n}"
    },
    {
      "name": "main.js",
      "path": "main.js",
      "language": "javascript",
      "content": "/**\n * Galaxy Defender - Main Game Controller\n * Integrates all game systems and manages the main game loop\n */\n\nclass GalaxyDefender {\n    constructor() {\n        try {\n            // Initialize all game systems\n            this.gameEngine = new GameEngine('gameCanvas');\n            this.player = new Player(this.gameEngine.canvas);\n            this.objectManager = new ObjectManager(this.gameEngine.canvas);\n            this.collisionDetector = new CollisionDetector();\n            this.scoreManager = new ScoreManager();\n            this.gameOverManager = new GameOverManager(this.scoreManager);\n            this.difficultyManager = new DifficultyManager();\n            this.uiManager = new UIManager();\n            \n            // Add notification styles\n            this.uiManager.addNotificationStyles();\n            \n            // Setup event handlers\n            this.setupEventHandlers();\n            \n            // Start the game loop\n            this.gameLoop();\n            \n            console.log('Galaxy Defender initialized successfully');\n            \n        } catch (error) {\n            console.error('Failed to initialize Galaxy Defender:', error);\n            alert('Failed to start the game. Please refresh the page and try again.');\n        }\n    }\n    \n    /**\n     * Setup all event handlers between systems\n     */\n    setupEventHandlers() {\n        // UI button handlers\n        this.uiManager.onButtonClick('start', () => this.startGame());\n        this.uiManager.onButtonClick('restart', () => this.restartGame());\n        this.uiManager.onButtonClick('resume', () => this.resumeGame());\n        this.uiManager.onButtonClick('pause', () => this.pauseGame());\n        \n        // Game over handler\n        this.gameOverManager.onGameOver((stats) => {\n            this.uiManager.showGameOverScreen(stats);\n            \n            // Create explosion effect at player position\n            this.gameEngine.createExplosion(\n                this.player.x + this.player.width / 2,\n                this.player.y + this.player.height / 2\n            );\n            \n            // Show game over message\n            const message = this.gameOverManager.getGameOverMessage(stats);\n            setTimeout(() => {\n                this.uiManager.showNotification(message, 4000);\n            }, 500);\n        });\n        \n        // Difficulty change handler\n        this.difficultyManager.onDifficultyChange((difficultyData) => {\n            this.objectManager.updateSpawnRate(difficultyData.level);\n            this.uiManager.updateLevel(difficultyData.level);\n            \n            // Create level up effect\n            this.gameEngine.createLevelUpEffect();\n            \n            // Show level up notification\n            this.uiManager.showNotification(`Level ${difficultyData.level}!`, 2000);\n        });\n        \n        // Prevent context menu on canvas\n        this.gameEngine.canvas.addEventListener('contextmenu', (e) => {\n            e.preventDefault();\n        });\n    }\n    \n    /**\n     * Start a new game\n     */\n    startGame() {\n        console.log('Starting new game');\n        \n        // Reset all systems\n        this.gameEngine.gameState = 'playing';\n        this.gameEngine.startTime = Date.now();\n        this.gameEngine.gameTime = 0;\n        this.gameEngine.particles = [];\n        \n        this.player.reset();\n        this.objectManager.clear();\n        this.scoreManager.reset();\n        this.gameOverManager.reset();\n        this.difficultyManager.reset();\n        \n        // Show game UI\n        this.uiManager.showGameUI();\n        \n        // Update initial UI values\n        this.uiManager.updateScore(0);\n        this.uiManager.updateTimer(0);\n        this.uiManager.updateLevel(1);\n        \n        // Show start notification\n        this.uiManager.showNotification('Game Started! Good Luck!', 2000);\n    }\n    \n    /**\n     * Pause the current game\n     */\n    pauseGame() {\n        if (this.gameEngine.gameState === 'playing') {\n            this.gameEngine.gameState = 'paused';\n            this.uiManager.showPauseScreen();\n            console.log('Game paused');\n        }\n    }\n    \n    /**\n     * Resume the paused game\n     */\n    resumeGame() {\n        if (this.gameEngine.gameState === 'paused') {\n            this.gameEngine.gameState = 'playing';\n            this.uiManager.showGameUI();\n            \n            // Adjust start time to account for pause duration\n            const pauseDuration = Date.now() - this.gameEngine.lastTime;\n            this.gameEngine.startTime += pauseDuration;\n            \n            console.log('Game resumed');\n        }\n    }\n    \n    /**\n     * Restart the game\n     */\n    restartGame() {\n        console.log('Restarting game');\n        this.startGame();\n    }\n    \n    /**\n     * Update game logic\n     */\n    update(currentTime) {\n        // Update game engine timing\n        this.gameEngine.updateTiming(currentTime);\n        \n        if (this.gameEngine.gameState === 'playing') {\n            // Update difficulty\n            this.difficultyManager.update(this.gameEngine.gameTime);\n            \n            // Spawn objects\n            this.objectManager.spawnObject(this.difficultyManager.getCurrentSpeed());\n            \n            // Update game entities\n            this.player.update();\n            this.objectManager.update();\n            \n            // Check collisions\n            const collisions = this.collisionDetector.checkPlayerCollisions(\n                this.player,\n                this.objectManager.getObjects()\n            );\n            \n            // Handle collisions\n            this.handleCollisions(collisions);\n            \n            // Update UI\n            const timeInSeconds = Math.floor(this.gameEngine.gameTime / 1000);\n            this.uiManager.updateTimer(timeInSeconds);\n        }\n        \n        // Always update particles and background\n        this.gameEngine.updateParticles();\n        this.gameEngine.updateBackground();\n    }\n    \n    /**\n     * Handle collision events\n     */\n    handleCollisions(collisions) {\n        // Process collisions in reverse order to avoid index issues\n        for (let i = collisions.length - 1; i >= 0; i--) {\n            const collision = collisions[i];\n            \n            if (collision.isGood) {\n                // Collect star\n                this.scoreManager.addScore(collision.points);\n                this.uiManager.updateScore(this.scoreManager.getScore());\n                \n                // Create collection effect\n                this.gameEngine.createCollectEffect(\n                    collision.object.x + collision.object.width / 2,\n                    collision.object.y + collision.object.height / 2\n                );\n                \n                // Remove collected object\n                this.objectManager.removeObject(collision.index);\n                \n            } else {\n                // Hit bad object - game over\n                this.gameOverManager.handleBadCollision(\n                    collision,\n                    this.player,\n                    this.gameEngine.gameTime,\n                    this.difficultyManager.getLevel()\n                );\n                \n                // Set game state to game over\n                this.gameEngine.gameState = 'gameOver';\n                return; // Exit early, game is over\n            }\n        }\n        \n        // Update total objects counter for statistics\n        if (collisions.length > 0) {\n            this.scoreManager.incrementTotalObjects();\n        }\n    }\n    \n    /**\n     * Render game graphics\n     */\n    render() {\n        // Clear canvas\n        this.gameEngine.clearCanvas();\n        \n        // Render background\n        this.gameEngine.renderBackground();\n        \n        // Render game entities if playing or paused\n        if (this.gameEngine.gameState === 'playing' || this.gameEngine.gameState === 'paused') {\n            this.player.render(this.gameEngine.ctx);\n            this.objectManager.render(this.gameEngine.ctx);\n        }\n        \n        // Always render particles for effects\n        this.gameEngine.renderParticles();\n    }\n    \n    /**\n     * Main game loop\n     */\n    gameLoop(currentTime = 0) {\n        try {\n            // Update game logic\n            this.update(currentTime);\n            \n            // Render graphics\n            this.render();\n            \n            // Continue game loop\n            requestAnimationFrame((time) => this.gameLoop(time));\n            \n        } catch (error) {\n            console.error('Error in game loop:', error);\n            \n            // Try to recover by showing error message and pausing\n            this.gameEngine.gameState = 'paused';\n            this.uiManager.showNotification('Game Error! Check console for details.', 5000);\n        }\n    }\n}\n\n// Initialize the game when the page loads\ndocument.addEventListener('DOMContentLoaded', () => {\n    // Add a small delay to ensure all resources are loaded\n    setTimeout(() => {\n        try {\n            window.galaxyDefender = new GalaxyDefender();\n        } catch (error) {\n            console.error('Failed to initialize Galaxy Defender:', error);\n            \n            // Show user-friendly error message\n            const errorDiv = document.createElement('div');\n            errorDiv.innerHTML = `\n                <div style=\"\n                    position: fixed;\n                    top: 50%;\n                    left: 50%;\n                    transform: translate(-50%, -50%);\n                    background: rgba(255, 0, 0, 0.9);\n                    color: white;\n                    padding: 20px;\n                    border-radius: 10px;\n                    text-align: center;\n                    z-index: 10000;\n                \">\n                    <h2>Game Failed to Load</h2>\n                    <p>Please refresh the page and try again.</p>\n